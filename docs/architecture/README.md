<h1 align="center">
    Architecture
</h1>

This section provides an explanation of the architecture of ML-Starter. The information is intended for contributors or
interested people.

ML-Starter has two main components:

1) Python backend with FastAPI which provides the REST-API.
2) React frontend

## Overview

The following UML component diagram shows the architecture of ML-Starter.

<img src="https://raw.githubusercontent.com/loki344/ml-starter/master/docs/images/architecture.png">
Each module represents an exchangable part of ML-Starter. This modular architecture allows an exchange of the front- or backend technologies, as long as the displayed interfaces are implemented. 

The UML sequence diagram shows the message and data flow of the application:

<img src="https://raw.githubusercontent.com/loki344/ml-starter/master/docs/images/sequence_diagram.png">
At the start of a session, the frontend will load the configuration to display the input-fields accordingly. As you can see, the pre- and postprocessing which is implemented by the user of the framework are called to inference with the model.


To simplify the deployment, the operation in docker is performed in a single container, containing the FastAPI and React
application. This is mainly due to the much simpler process to deploy this container on Heroku.

<img src="https://raw.githubusercontent.com/loki344/ml-starter/master/docs/images/docker_operation.png">

## Backend

The main functionality of ML-Starter is provided by the Python backend. The REST-API is implemented with FastAPI and
provides the following endpoints:

<img src="https://raw.githubusercontent.com/loki344/ml-starter/master/docs/images/rest-endpoints.png">

The used classes of the Python application are shown in the below class diagram which is automatically generated by
pyreverse.

<img src="https://raw.githubusercontent.com/loki344/ml-starter/master/docs/images/classdiagram.png">
<strong>AbstractModel</strong><br>
This parent class ensures the main flow of the inference logic. Child classes must implement a predict, pre_process and post_process method. <br>
<strong>PMML and ONNX Model</strong><br>
These parent classes allow users to implement the pre- and postprocessing according to their model-format. The predict method is already implemented and takes care of the right order of the method calls. Child classes must implement a pre_rpocess and post_process method.
<strong>Configuration service</strong><br>
This service validates the configuration and provides the configuration keys as fields.
<strong>PersistenceService</strong><br>
In order to persist the requests and responses to a datasource, the PersistenceService provides an interface to ensure the necessary functionalities. A child class must provide an implementation for all methods.
<strong>InMemoryDbService</strong><br>
Allows to persist predictions in an inMemory SQLite database. The file-based database is placed in the directory ml-starter/backend/app/persistence.
<strong>MongoDbService</strong><br>
Provides a connection to the online db service https://www.mongodb.com/ and allows to save predictions. This service expects the configuration keys for the database connection.
<strong>PredictionBase, PredictionCreate, PredictionPatch, Prediction</strong><br>
These classes are mainly used to define the requestBody in the REST-API and to create the SQLite tables.
<strong>Prediction</strong><br>
This model is used to communicate with the MongoDBService. It defines the structure of the saved documents.




## Frontend

The dependency graph below is generated with dependency-cruiser and gives an overview of the frontend:

<img src="https://raw.githubusercontent.com/loki344/ml-starter/master/docs/images/dependencygraph_frontend.png">

### Inputfields

The functionality for the handling of the input data is in the InputDataForm.js, PredictionForm.js and the
StartPredictionButton.js.

The InputDataForm.js is responsible to generate the configured input fields that are fetched with the configuration:

```javascript
   <div className={"InputDataForm" + '' + getClassForInputForm()}>
    // generates an element for every configured input field
    {inputFields.map((inputField) => (
        <InputField key={inputField.label} inputField={inputField}>
        </InputField>
    ))}
    <StartPredictionButton/>
</div>
```

The configuration is stored in the redux store:<br>
<img src="https://raw.githubusercontent.com/loki344/ml-starter/master/docs/images/configInpuFields.png">

Every InputField element in turn is responsible to adjust to the desired type of the configured input field.

<details><summary>Relevant code of InputField.js</summary>
   <p>

   ```javascript
let htmlTag
switch (type) {

    case 'image':
        htmlTag = (
            <div style={{textAlign: 'center'}}>
                <label className="InputLabel">{label}</label>
                <input onChange={async (event) => {
                    if (!validateFile(event.target.files[0])) {
                        Notiflix.Notify.Failure("File format not allowed")
                        setFileName('Allowed formats: jpg, jpeg, png')
                        setTextColor('red')
                        event.target.value = null
                        return
                    }
                    setTextColor('black')
                    dispatch(addData(id, await toBase64(event.target.files[0])))
                    setFileName(event.target.files[0] !== undefined ? event.target.files[0].name.substring(0, 30) : 'No file chosen')
                }} type="file" accept="image/*" id="actual-btn" hidden/>
                <br/>
                <label className="FileLabel" htmlFor="actual-btn">Choose File</label>
                <br/>
                <br/>
                <div id="file-chosen" style={{color: textColor}}>{fileName}</div>
                <img style={{marginTop: "2rem", width: "auto", maxHeight: "30rem"}} src={fileData}/>
            </div>)
        break

    case 'number':
        htmlTag = (
            <div style={{marginBottom: '1.5rem'}}>
                <label className="InputLabel">{label}</label>
                <input className="InputField" type="number" step="any"
                       onChange={(event) => dispatch(addData(id, event.target.value))}/>
            </div>

        )
        break

    case 'str':
        htmlTag = (
            <div style={{marginBottom: '1.5rem'}}>
                <label className="InputLabel">{label}</label>
                <input className="InputField" type="text"
                       onChange={(event) => dispatch(addData(id, event.target.value))}/>
            </div>
        )
        break
    default:
        return <p>The configured type of the input field is not supported. Type: {type}</p>
}

return (<>{htmlTag}</>)
   ```

   </p>
   </details>

This results in the view:

<img src="https://raw.githubusercontent.com/loki344/ml-starter/master/docs/images/generatedinputfields.png">

To ensure the desired structure of the model in the backend, the StartPredictionButton.js maps the values of the input
fields to the configured requestObject. It uses the id of the fields to replace the values.

```javascript
//... code ommitted
let requestData = JSON.stringify(requestObject.inputData)

for (let inputField of inputFields) {
    let inputFieldToReplace = inputField.id
    requestData = requestData.replace(inputFieldToReplace, inputData[inputField.id])
}

let requestBody = '{"input_data":' + requestData + '}'
requestBody = JSON.parse(requestBody)

await dispatch(postPrediction(requestBody))
//... code ommitted
```

So this:

<img src="https://raw.githubusercontent.com/loki344/ml-starter/master/docs/images/requestObjectRaw.png">

Is transformed to this:

<img src="https://raw.githubusercontent.com/loki344/ml-starter/master/docs/images/requestbody.png">

### Prediction

Predictions can either be a single value (String, Number, Boolean) or an object. Additionally, these predictions can be
wrapped inside an array. In order to reduce the complexity of rendering the prediction, the predictionActions.js wraps
single values in an array.

```javascript'
//PredictionActions.js
//...code ommitted
let payload = {
   "id": data.id,
   "prediction": typeof data.prediction === 'object' || data.prediction instanceof Array ? data.prediction : [data.prediction]
}
//...code ommitted
```

The rendering in the PredictionForm.js can then loop over the array of predictions and creates the items.

```javascript
<div>
    {
        prediction.map((pred) => (
            <>
                <PredictionItem predictionObject={pred}/>
            </>
        ))
    }
</div>
```

Each PredictionItem in turn can be a single value or an object with fields. The PredictionItem.js adjusts its rendering to the structure of the prediction.

```javascript
typeof prediction === 'object' && prediction !== null ?
    <>
        {
            //Render the fields of an object
            Object.keys(prediction).map(key =>
                <div>
                    <span className="PredictionItem">{key}:</span>
                    <span className="PredictionItem">{prediction[key]}</span>
                </div>
            )
        }

        <div style={{marginBottom: "1rem"}}/>
    </>
    :
    <div className="PredictionItem"
         style={{gridColumnStart: '1', gridColumnEnd: -1}}>
        {
            //Render a single value (string, number, boolean)
            typeof prediction === 'boolean' ?
                prediction.toString() : prediction

        }
    </div>
```
